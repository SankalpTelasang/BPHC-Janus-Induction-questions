# BPHC-Janus-Induction-questions 
2025A4PS1044H Sankalp Telasang

# Q1
For question 1, I began with researching noise filtering methods, and settled on a LOESS method. This uses the local region of a point to smooth the curve, and for my implementation specifically, I consider the nearest 2 points (the previous and next value in time). I multiply those by a weight, and multiply the value of the point itself by a weight and then add it together to get the smoothed point. After this, I noticed that the data had some corrupted values, and so I implemented detection and simple interpolation for these values. After this, I began the first step of my error correction, which is to detect erroneous points. The method I used is to generate the LOESS graph for the data, check each data point's difference from the LOESS curve, and if it is above some maximum acceptable value, then it is removed and interpolated from the nearest 2 points. After a few rounds of doing this, all the points will be within the minimum acceptable value, and so every point is considered non-erroneous. The final step of data manipulation is to generate the final LOESS curve using the same method mentioned above.

Something to note, is that for my implementaion I have made it very general. It will work for any set of values that you pass in, as long as that data is in the first column of a csv document. There are some assumptions, for example that every subsequent row is at some predifined and uniform interval from the previous one, and of course some of the constants are calibrated for this data set specifically. On top of that, it assumes that corrupted values will be marked with 5 asterisks (*****), and that the inputed data can be converted into floats. Also, the data processing section must be changed for each csv, currently it is of course configured for turning pressure data into height data. This section is marked clearly in the code.

# Q2
For question 2, I already had some experiencing wiring sensors to arduinos, so I built a simple voltage divider connected to the force sensor to measure it. I found that giving the resistor in the voltage divider 10 kiloohms yielded a good sensitivity. Next, I hooked up the 2 LEDs and the piezo buzzer. After that, the wiring was complete so I started the coding section.

For the coding section, the first thing I did was to implement a simple low pass noise filtering on the values from the force sensor. This was done by having half of the current force value actually come from the previous iteration of the loop, and half from the current reading. The equation is pretty simple, smoothed_force = (current_force * 0.5) + (smoothed_force * 0.5). After this, I decided that this would not be sufficient noise filtering, so I added another system as well. That system looks at the past 20 deltas (the difference between the current and previous force reading), and if 17 of them are positive, then it will say that the system is descending (since an increase in pressure means lower altitude). If 17 are negative, then it will of course say that the system is ascending. This system also had the effect of making the detection a lot less sensitive, and essentially optimizes this arduino for fast and continous ascension (for example a model rocket). After this, all that was left was detecting when the arduino was at the apex of it's trajectory, so I added a simple trigger that would do this. If the arduino is not ascending, and it was ascending the previous iteration of the loop, then it will trigger the apex detection and ring the buzzer.
